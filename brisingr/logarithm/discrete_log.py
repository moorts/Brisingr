import math
from typing import Optional, Callable

def naive_discrete_log(g: int, h: int, p: int) -> Optional[int]:
    for x in range(1, p - 1):
        if pow(g, x, p) == h:
            return x

    return None

def baby_step_giant_step(g: int, h: int, p: int, N=None) -> Optional[int]:
    """
    Solve discrete logarithm problem using babystep-giantstep algorithm.

    Args:
        g: base
        b: right-hand side
        p: order of finite group
        N: order of g (default to p)

    Returns:
        Solution of g^x = b (mod p) for x.
    """
    if not N:
        N = p
    n = 1 + math.isqrt(N)

    # Baby Steps: {e, g, g^2, ..., g^n}
    baby_steps = { pow(g,j,p) : j for j in range(n+1) }

    g_inv = pow(g, -1, p)

    # g^{-n}
    giant_stepper = pow(g_inv, n, p)

    # Giant Steps: {b, b*g^{-n}, b*g^{-2n}, ..., b*g^{-n^2}}
    giant_step = h
    for i in range(n+1):
        if giant_step in baby_steps:
            solution = i*n + baby_steps[giant_step]

            assert pow(g, solution, p) == h
            return solution
        giant_step = (giant_step * giant_stepper) % p
    
    # No solution exists (h is not in subgroup generated by g)
    return None


def prime_power_pohlig_hellman(g: int, h: int, p: int, q: int, e: int) -> Optional[int]:
    """
    Solve discrete logarithm problem for element with order q^e, q prime

    g^x = h (mod p) and g^(q^e) = 1 (mod p)
    """
    solution = 0

    order = pow(q, e)

    assert((p-1) % order == 0)

    g_inv = pow(g, -1, p)
    g_order_q = pow(g, pow(q, e-1, order), p)

    q_to_the_i = 1

    # rhs = (h*g^(-x_0-x_1q-...-x_{i-1}q^{i-1}))^{q^{e-i-1}}
    rhs = h
    for i in range(e):
        x_i = baby_step_giant_step(g_order_q, pow(rhs, pow(q, e-i-1, order), p), p, N=q)

        if not x_i:
            return None

        rhs = (rhs * pow(g_inv, x_i*q_to_the_i, p)) % p
        solution = (solution + x_i*q_to_the_i) % order
        q_to_the_i = (q_to_the_i * q) % order

    return solution


def solve_congruence_system(rhs, moduli):
    """Solve a system of congruences by the chinese remainder theorem

    Find x so that for each 0 <= i < len(rhs):
    x = rhs[i] (mod moduli[i])

    Args:
        rhs: List of right-hand sides of the congruences
        moduli: Moduli for each of the congruences
    Returns:
        Solution to the system
    """
    solution = rhs[0]
    increment = moduli[0]
    for (current_rhs, modulus) in zip(rhs[1:], moduli[1:]):
        while solution % modulus != current_rhs:
            solution += increment
        increment *= modulus
    return solution % increment


def garner(rhs, moduli) -> int:
    """Solve system of congruences via the garner algorithm.

    See: https://cp-algorithms.com/algebra/garners-algorithm.html

    Views the solution in mixed radix representation, i.e.
        a = x_1 + x_2*moduli[0] + x_3*moduli[0]*moduli[1] + ...

    Then recovers the x_i iteratively by using the observations that:
        rhs[0] = x_1 (mod moduli[0])
        rhs[1] = x_1 + x_2*moduli[0] (mod moduli[1])
        ...

    where each equation can be solved with knowledge of the previous solutions.
    """
    mixed_radix = []
    for i in range(len(rhs)):
        current = rhs[i]
        for j in range(i):
            inv = pow(moduli[j], -1, moduli[i])
            current = inv * (current - mixed_radix[j]) % moduli[i]
        mixed_radix.append(current)
    factor = 1
    solution = 0
    for i, x in enumerate(mixed_radix):
        solution += x * factor
        factor *= moduli[i]
    return solution


def naive_factorize(n: int) -> list[tuple[int, int]]:
    """Brute force the prime factorization of n
    """
    x = n
    factorization = []
    for i in range(2, n):
        if x == 1:
            break
        exp = 0
        while x % i == 0:
            exp += 1
            x //= i
        if exp > 0:
            factorization.append((i, exp))
    return factorization


def pohlig_hellman(g: int, h: int, p: int, factorize: Callable[[int], list[tuple[int,int]]]) -> Optional[int]:
    """Solve the discrete logarithm problem by the pohlig-hellman algorithm

    Args:
        g: base of the discrete log
        h: right-hand side value
        p: Order of the finite field
        factorize: routine to factorize the order of the multiplicative group of the field

    Returns:
        Solution x to g^x = h (mod p)
    """
    factors = factorize(p-1)

    rhs = []
    moduli = []
    for (q, e) in factors:
        # There is a subgroup of elements with order q^e
        order = pow(q, e)
        # from g we get a generator of this subgroup
        g_q = pow(g, (p-1) // order, p)
        # and elevate h to this subgroup
        h_q = pow(h, (p-1) // order, p)

        # Calculate discrete log of in subgroup of order q^e
        # then we have a solution y for: (g^(q^e))^y = h^(q^e) = (g^x)^(q^e)
        # it follows that y * q^e = x * q^e (mod q^e) and therefore
        #                 y = x (mod q^e)
        y = prime_power_pohlig_hellman(g_q, h_q, p, q, e)

        if not y:
            return None

        rhs.append(y)
        moduli.append(order)

    # Combine solutions
    x = garner(rhs, moduli)

    assert pow(g, x, p) == h

    return x


def order(
        g: int,
        p: int,
        N: int,
        factorize: Optional[Callable[[int], list[tuple[int, int]]]] = None) -> int:
    """Find order in F(p)
    Args:
        g: element of F(p)
        p: order of F(p)
        N: order of multiplicative group (phi(p))
        factorize: [optional] factorization routine, for smooth numbers factorization is easy,
                   therefore we can use knowledge of the factors to speed up calculating the order.

    """
    if not factorize:
        i = 1
        x = g
        while x != 1:
            x = (g * x) % p
            i += 1
        return i

    factors = factorize(N)
    for (q, _) in factors:
        if pow(g, N // q, p) == 1:
            # ord(g) | N // q => recursion
            return order(g, p, N // q, factorize)
    return N


g = 281
h = 92646
p = 234917
#print(baby_step_giant_step(g,h,p))
#print(prime_power_pohlig_hellman(5448, 6909, 11251, 5, 4))
#print(solve_congruence_system([2,3,4], [3,7,16]))
#print(garner([1979, 318210093451, 184, 2, 1], [5417, 420233272499, 293, 4, 3]))
#print(pohlig_hellman(g, h, p, naive_factorize))
import random
import math

p = 6006856703
g = 5
# x = random.randint(2, p - 1)
# h = pow(g, x, p)
h = 82414580
x = baby_step_giant_step(g, h, p)

print(f"p: {p}")
print(f"g: {g}")
print(f"h: {h}")
